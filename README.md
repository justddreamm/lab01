# lab01
report
## Лабораторная работа №01 Лагов Сергей ИУ8-22

1. Скачайте библиотеку *boost* с помощью утилиты **wget**. Адрес для скачивания `https://sourceforge.net/projects/boost/files/boost/1.69.0/boost_1_69_0.tar.gz`
```
wget <здесь_наша_ссылка>
```
Скачали библиотеку

`wget` - утилита, позволяющая скачать файл

2. Разархивируйте скаченный файл в директорию `~/boost_1_69_0`
```
cd ~/boost_1_69_0
tar -xf boost_1_69_0.tar.gz
```
Создали `~/boost_1_69_0` и разархивировали в неё библиотеку

`cd` - "change directory", что значит "сменить директорию"

`tar` - утилита для разархивирования файла

`x` - извлечение требуемых документов из архива

`f` - вывод результата в определённый файл (или на конкретное устройство)

3. Подсчитайте количество файлов в директории `~/boost_1_69_0` **не включая** вложенные директории
```
ls /home/lagov/boost_1_69_0| wc —l
2
ls /home/lagov/boost_1_69_0| wc —l
18
```
Дело в том, что я в начале по ошибке создал не те директории в не тех местах, поэтому получилась небольшая путаница с папкой `workspace`. Из-за этого у меня получилось всего 2 файла в директории. Когда я понял, что ошибся, я скорректировал расхождения с заданием через проводник. После этого всё верно посчиталось (18, так как в директории лежали ещё 2 сторонние папки)

`ls` - вывести на консоль файлы

`|` - штука, позволяющая принять вывод за аргумент следующей команды. Иными словами мы пихаем то, что получили, в другую функцию

`wc` - утилита, анализирующая файлы на основе данных параметров (далее опишу, каких)

`-l` - параметр `wc`, говорящий о необходимости посчитать полученные файлы

4. Подсчитайте количество файлов в директории `~/boost_1_69_0` **включая** вложенные директории
```
cd /home/lagov/boost_1_69_0
find ./ -type f | wc -l
61191
```
Собственно, подсчитали

`find` - ищёт файлы в директории

`./` - штука, а конкретнее эта точка `.`, символизирующая настоящую директорию, где мы находимся

`-type` - вид файла, описанные в параметре далее

`f` - параметр, описавающий тип файла. В данном случае - все файлы

5. Подсчитайте количество заголовочных файлов, файлов с расширением `.cpp`, сколько остальных файлов (не заголовочных и не `.cpp`)
```
find ./ -type f -name "*.h" | wc -l
296
find ./ -type f -name "*.cpp" | wc -l
13774
find ./ -type f \( ! -name "*.cpp" ! -name "*.h" \) | wc -l
47121
```
Здесь посчитали по очереди хедеры, исполнительные файлы, а также те, что не являются ни теми, ни теми. Команду `ls` заменили на `find`.

`-name` - поиск файлов по имени

`"*.h"` - аргумент, описывающий формат нужного файла

`"*.cpp"` - *-||-*

`!` - отрицание. В данном случае говорит, что ищем все, но НЕ те, что отрицаются, то есть исполнительные и хедеры

6. Найдите полный пусть до файла `any.hpp` внутри библиотеки *boost*
```
find "$(cd ..; pwd)" -name "any.hpp"
/home/lagov/boost_1_69_0/boost/spirit/home/support/algorithm/any.hpp
/home/lagov/boost_1_69_0/boost/proto/detail/any.hpp
/home/lagov/boost_1_69_0/boost/fusion/include/any.hpp
/home/lagov/boost_1_69_0/boost/fusion/algorithm/query/detail/any.hpp
/home/lagov/boost_1_69_0/boost/fusion/algorithm/query/any.hpp
/home/lagov/boost_1_69_0/boost/hana/fwd/any.hpp
/home/lagov/boost_1_69_0/boost/hana/any.hpp
/home/lagov/boost_1_69_0/boost/xpressive/detail/utility/any.hpp
/home/lagov/boost_1_69_0/boost/type_erasure/any.hpp
/home/lagov/boost_1_69_0/boost/any.hpp
```
Нашли пути ко всем файлам `any.hpp` в библиотеке

`"$(cd ..; pwd)"` - говорит системе, что для каждого найденного файла следует прописать его путь `pwd`, при этом подняться в вышестоящую папку `cd ..`

7. Выведите в консоль все файлы, где упоминается последовательность `boost::asio`
```
grep -rnw ./ -e boost::asio
```
Здесь выводится миллиард строк текста файлов, где есть упоминание

`grep` - даёт возможность сортировать и фильтровать текст на основе данных правил

`r` - рекурсивный поиск, то есть поиск чего-то во всех подкаталогах

`n` - показывает номер строки в файле

`w` - искать шаблон как слово, окружённое пробелами. В нашем случае это `boost::asio`

`e` - включает режим регулярного выражения, то есть шаблон, который соответствует набору строк

8. Скомпилируйте *boost*. Можно воспользоваться [инструкцией](https://www.boost.org/doc/libs/1_61_0/more/getting_started/unix-variants.html#or-build-custom-binaries) или [ссылкой](https://codeyarns.com/2017/01/24/how-to-build-boost-on-linux/)
```
cd tools/build/
sudo ./bootstrap.sh
./b2 install --prefix=BoostBuild
export PATH=${PATH}:`pwd`/BoostBuild/bin
cd ..
cd ..
b2 --build-dir=/tmp/build-boost toolset=gcc stage
```
Не смог скопировать команды из консоли, так как после того, как я нажал `Enter` всё начало компилироваться, причём так долго, что я успел проиграть 2 партии в шахматы. Поэтому команды, какие вбивал, писал на память, сверяясь с инструкцией

Работаем по инструкции

*Go to the directory tools/build/.*

*Run bootstrap.sh*

*Run b2 install --prefix=PREFIX where PREFIX is the directory where you want Boost.Build to be installed*

*Add PREFIX/bin to your PATH environment variable.*

`sudo ./bootstrap.sh` - запуск исполнительного файла от имени суперпользователя

`install` - установить

9. Перенесите все скомпилированные на предыдущем шаге статические библиотеки в директорию `~/boost-libs`.
```
mkdir ~/boost-libs
mv /home/lagov/boost_1_69_0/boost /home/lagov/boost_1_69_0/boost-libs
```
Самое простое - создаём директорию и с помощью команды `mv` переносим библиотеки по указанному пути

`mkdir` - создаёт директорию

`mv` - функция перемещения чего-то куда-то

10. Подсчитайте сколько занимает дискового пространства каждый файл в этой директории
```
du -a -h
```
Здесь команда выводит невероятное количество файлов, указывая размер каждого

`du` - позволяет вывести размер всех файлов в определённой папке в байтах или в более удобном формате

`a` - выводить размер для всех файлов, а не только для директорий (по умолчанию размер выводится только для папок)

`h` - выводить размер в единицах измерения, которые будут удобны для человека

11. Найдите *топ10* самых "тяжёлых"
```
du -Sh | sort -rh | head -10
```

`S` - позволяет не включать размер подпапок в размер папки 

`sort` - утилита для сортировки с заданными параметрами

`r` - говорит системе сортировать в обратном порядке

`h` - теперь в качестве разделителя полей будет использован наш символ, а не пробел

`head` - выводит начальные строки из одного или нескольких документов. Но она может и показывать данные, которые передает на вывод другая утилита, что реализуется в нашем случае

`10` - говорит о том, что нам нужно именно 10 строк, так как у нас топ десяти файлов

Здесь аналогично. Разница лишь в том, что выводятся не все, а только 10 файлов, который, к тому же, ещё и сортируются. Трудности, с которыми я столкнулся:
Порой было трудновато понять, каким образом работает та или иная команда. Некоторое время ушло на осознание смысла каждой буквы параметров. Также раздражала комбинация клавиш, которая отвечает за копировать/вставить в терминале и обычной среде Ubuntu. Где-то добавляется `Shift`, где-то его использование ведёт к тому, что открывается какое-то левое окно с ненужной инфой, и приходится тратить время, чтоб закрыть то, что открылось и уже нормально скопировать то, что изначально должно было быть скопировано. Последнее, что мне помешало, была компиляция. Ubuntu ушла на покой компилировать, пока мы пошли играть в шахматы, а это далеко не быстро. Когда вернулись, система еще долго работала, а затем не реагировала на нажатия. В какой-то момент всё ожило, но все логи терминала потёрлись и вообще это заняло много времени. В остальном особых проблем не наблюдалось
